---
title: 对象
date: 2021-3-17
tags:
 - tag4
categories: 
 - JS-node
---

# 对象

**万物皆对象**（除了undefined 和 null）

##### 定义

var 对象名{

​		键（key）：值（value）,

​		键（key）：值（value）,

​		键（key）：值（value）

}

当key不存在时，value就是undefined

对象没有长度，所以遍历对象用for...in..

key是字符类型，如果不是字符类型，会隐式转换为字符型

对象的方法：

点语法：后面只能添加属性，不能添加变量，也不能添加数字开头的

方括号语法：可以直接添加属性，也可以通过变量来添加属性

```javascript
var obj = {a:1}
console.log(obj)//结果是{a:1} 但是点开这个对象之后，a的值就变成了10
obj.a = 10
//原因： 对象会在栈里面存储对象名和一个引用地址，真正的{a:1}存储在了堆里面，堆里面返回一个引用地址给栈，然后页面加载的时候，打印出来的是栈里面存储的{a:1} 然后点开这个对象之后，页面就会在堆里面去寻找这个引用地址所保存的数据，然后显示出来
```

对象是在栈中开辟一个变量名的空间，存储一个堆中的引用地址，把这种情况统一的称为引用类型

###### 数值对象

```javascript
var a = new Number(5) // 数值对象
// a存在 堆 里面了，为了加快运行速度，就会在 栈 中做一个映射
var a = 5 // 数值
// 在 栈 里面，如果想引用方法，就会去 堆 里面的 数值对象 中查找
```

###### 字符串对象

###### 布尔对象

和数值对象一样，都会先在堆里面存储，然后再在栈里面映射出来

只有这3个可以直接在堆里面查找

##### undefined和null的区别

###### undefined

```javascript
//只是代表这个a开辟了一个空间
var a ;或者 var a = undefined
```

```javascript
var s = 78; s = undefined //  只是将这个s这个的空间变量清空
```

###### 内存泄漏

不断引用新的对象，但是并没有清除掉不再引用的对象，造成这些对象在堆中形成了无法使用的孤儿对象

###### 垃圾回收机制

将堆中对象中引用列表中的变量名为空的对象进行回收

###### null的作用：

（只限于对对象操作）typeof null 为object 

1.将栈中的变量清空引用关系

2.清空堆中该对象中的引用列表中的变量名

###### 面试题：

```javascript
var a = {n:1}
var b = a 
a.x = a = {n:2}
console.log(a.n , b.n) // 2,1
console.log(a.x , b.x) // undefined,{n:2}
// 思路
// 第一步：先将a这个对象给b 那么就是a和b同时存储了一个引用地址 {n:1}
// 第二步：将a = {n:2}的结果给了a.x 那么现在那个引用地址存储的内容就是{n:1,x:{n:2}} 然后将{n:2}这个对象赋给a 那么a的引用地址就改变了
// 第三步：所以现在a的值就是{n:2} b还是原来那个地址 所以b的结果是 {n:1,{n:2}}
```

变形:

```javascript
var a = {n:1}
var b = a
a = a.x = {n:2}
console.log(a.n , b.n) // 2,1
console.log(a.x , b.x) // undefined,{n:2}
// 思路
// 第一步：先将a这个对象给b 那么就是a和b同时存储了一个引用地址 {n:1}
// 第二步：将a.x = {n:2}的结果给了a 那么现在那个引用地址存储的内容就是{n:2},并且a的引用地址改变了
// 第三步：然后将{n:2}这个对象赋给a.x 此时这个表达式还没有执行完毕，所以现在a的引用地址还是{n:1} 所以a.x = {n:2}就会在原本的引用地址上操作
// 第四步：然后这个表达式操作完毕之后 原本的引用地址就是{n:1,{n:2}} a的新的引用地址就是{n:2}
// 第五步：所以现在a的值就是{n:2} b还是原来那个地址 所以b的结果是 {n:1,{n:2}}
```

###### 复制对象

**浅复制**

```javascript
var obj = {a:1,b:2,c:3}
var o = {}
第一种方法：
for(var key in obj) o[key] = obj[key]
第二种方法
o = Object.assign({},obj)
第三种方法
Object.assign(o,obj)
第四种方法
o = JSON.parse(JSON.Stringify(obj))
```

**深复制**：递归

##### 内存和硬盘的区别

内存：容器小，关闭之后信息不保存，会临时存放大量数据。运行速度快

硬盘：容器大，关闭之后信息还是会保存，但是调用的时候不方便。

##### 堆和栈的区别

栈：存储数值，字符串，数组，Symbol，undefined，布尔等。存储引用地址（除了undefined，null）

堆：存储对象的值

##### JSON

JSON.Stringify()：将对象转换为一个JSON格式的字符串

JSON.parse()：将JSON字符串转换为对象

##### 关于对象中的this问题

```javascript
var obj = {
    a:1,
    b:2,
    c:this.a, // 此时因为obj还没有创建完成，所以当前的this就是对象外的this
    d:function(){
        console.log(this.b) // this指向的是当前的对象，谁调用d函数，this指向的就是谁
    }
}
```
























---
title: 正则表达式
date: 2021-8-12
tags:
 - tag4
categories: 
 - JS-node
---


# 正则表达式

#### 创建

1.字面量创建

var reg=/正则表达式内容/修饰符

2.实例化创建

var reg=new RegExp("正则表达式内容","修饰符")

#### 修饰符

g  //全局查找

i    //不区分大小写

m   // 多行查找

#### 正则表达式方法

1.正则表达式.exec(“字符串”) //在字符串中查找（只能查找第一个）

属性：0：字符串；index：索引；input：整个字符串

2.正则表达式.test("字符串")  // 表示在字符串中查找是否有这个字符

注意： 同一个正则表达式不要连用test，因为第一个查询结束后会保留查询到的指针下标，下一次会继续这个指针下标继续寻找

   var reg=/a/;

 console.log(reg.test("cabc"));

  console.log(reg.test("cdade"));

#### 字符串方法

1. match

字符串.match(正则表达式)

注意：如果不加g,则跟exec()方法一样，会返回相应属性

加了修饰符就会查找符合要求的字符，并且将其截取出来放在数组中

2. search：

只能查找一个，不能查找多个，只能查找下标

3. replace

字符串.replace(正则表达式,字符串/函数)

‘assign'.replace('/a/g',function(a,b,c){

​	if(b===0) return 0

​	else return '2'

})

4. split

字符串.split(正则表达式，多少个)

#### 元字符

通配符：（.）可以匹配任意一个字符

转义字符（\）转义有其他含义的字符

[]代表其中的任意一个字符，相同的字符只取一个，另一个无意义

.到了[]里面，就是字符（.）不再是通配符

[]内再匹配左[和右]都需要转义字符\转义，{}（）同样需要

[a-zA-Z0-9]表示字母和数字其中任意一个

[A-z]不可以表示字符中任意一个，因为ACSLL码中91—96之间的是非字母字符

#### 反义字符

[^]不要^后面的字符，写在[]最前面，表示[]内的内容都不要，但是如果^在[]内不是最前面，表示的就是^字符

[^oa]表示不要o和a   [a^o]表示字母a^o中的任意一个

#### 简写

\w   表示[a-zA-Z0-9_]

\W   表示[  ^a-zA-Z0-9]

\d   表示 [0-9]

\D   表示[ ^0-9]

\s   表示空白字符 \br \n等

\S   表示非空白字符

#### 重复

{n} 表示要重复的次数，n表示重复几次

{1}表示匹配{}前面的字符一次

{0}表示匹配空字符串

[{}]表示匹配{}中的任意一个

{m,n} 表示重复次数m~n次，先匹配大的n次，再依次往下匹配

{0,n}最后会匹配一个空白字符

{4，4}=>{4}

当，后面没有数值时，表示匹配最大，无穷

{0，}表示可以没有，也可以有无穷多个   （*）   y *y * ===>简化 y *

{1，}表示可以有一个以上的                      （+）   z+z+z+  ===>简化z{3，}

{0，1}表示可以没有，也可以有一个        （?）	x?x?x?   ===> 简化x{0,3}

#### 非贪婪匹配

要有前后字符，并且将非贪婪字符写在中间

.*?   找到第一个符合要求的，前后字符中间可以没有字符，也可以有多个字符

.*+  找到第一个符合要求的，前后字符中间至少有1个字符

“address”.match(/a.*?d/) ==> ad

"address".match(/a.*+d/) ===> add

#### 起始字符和结束字符

^                     $

#### 或者

|

1~31

/^[1-9]$|^[1,2]\d$|^3[01]$/

正则匹配IP

/^(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])){3}$/

邮箱匹配

/^\w+@\w+\.(com|net|edu|cn)(\.(cn|cc|jp|tw)?)$/

#### 小组

（）组

**作用：**

1.可以让很多或者部分作为一整块，还可以将多个部分作为整体做重复

2.使用match或者replace可以作为筛选部分处理

3.重复筛选

4.断言：前置肯定断言、前置否定断言、后置肯定断言、后置否定断言

案例：

”15[action]".match(/(\d+)\ [([a-zA-Z0-9]+)\ ]/).slice(1)  //  ['15','action']

"《西游记》，《三国演义》，《红楼梦》，《水浒传》".replace(/《(.*?)》/g,function(item,$1){

​		return $1 // 西游记，三国演义，红楼梦，水浒传

})

"18941564567".replace(/(\d{3})\d{4}(\d{4})/g,$1 **** $2 ) // 189****4567

"dhsaodhskjadchahduashjkasgdshadjkhasjdhljashd".split("").sort().join("").replace(/([a-zA-Z0-9])\1*/g,function(item){

​	return item[0]+"{"+item.length+"}"  //a{2}b{4}c{3}...

})

断言：是一个条件，条件不占位，只是用来判断

"abacad".replace(/(?=c)/g,"0")    // 后置肯定断言   ab0cad

"abacad".replace(/(?!c)/g,"0")     //后置否定断言    0bac0d

"bacada".replace(/(?<=c)/g,"0")    // 前置肯定断言   bac0da

"bacada".replace(/(?<!c)/g,"0")     //前置否定断言    b0cad0

"30+50=80".match(/\d+$/g)     // '80'

"30+50=80".match(/^\d+/g)     //'30'

"30+50=80".match(/^(?=\d+)./g)     //'3'

面试题：2[2[2[ab]2[cd]]3[e]]

```javascript
function parse(str){
    var regExp=/(\d+)\[([a-zA-Z]+)\]/
    if(!regExp.test(str)) return 
    return parse(str.replace(regExp,function(item,$1,$2){
        return $2.repeat($1)
        }))
}
```

